# 分布式事务

### 项目概要

1. 使用二阶段提交及随机协调者的设计，保证事物一致性 
2. 使用时间戳排序协议实现乐观锁，提供系统并发能力并保证事务隔离性和原子性 
3. 解决分布式事务中存在的死锁问题，通过自动回滚事物实现死锁解除



### 项目描述

​	分布式事务这个项目实现了一个分布式事务系统，系统采用了二阶段提交+时间戳排序协议，实现了事务四大特性中的ACI。其中原子性和隔离性是通过实现时间戳排序实现的，隔离级别为read committed（读提交），一致性是在二阶段提交的第一阶段进行检查，如果违反一致性则会执行事务回滚操作。系统中有固定的5台服务器，分别代表5个分支，用户可以通过标明前缀的方式决定对象存储在哪台服务器中。用户的操作主要为BEGIN（开启事务），ABORT（中断并会滚事务），COMMIT（提交事务），DEPOSIT（账户存款），BALANCE（查询余额），WITHDRAW（提取余额）。同一事物可以对不同分支下的账户进行查询或修改，事物会在提交时判断事物执行的成功与否，如果该事物破坏了隔离性或一致性则会进行回滚。



### 相关知识点

#### CAP定理

在分布式系统架构设计中，CAP三大特性只能最多满足其二。Consistency代表数据的一致性，指的是对所有节点查询同一变量时，返回值都是一样的。Availablility代表节点可用性，指的是所有节点能够正常相应接收到的请求。Partition Tolerance代表分区容错性，指的是系统出现网络分区的情况下还是否能够正常运作。    

**CA**：当满足一致性和可靠性时，系统中的每两节点之间都需要正常通信以更新存储变量的值，如果出现网络分区的情况则打破了正常通信的条件。

**CP**：当满足一致性和分区容错性时，如果产生网络分区的情况，由于系统需要维持一致性而不同分区之间又无法进行通信，因此只能将其中一个分区定义为可用状态，违反了可用性。

**AP**：当满足可用性和分区容错性时，出现网络分区时需要节点节点都为可用状态，但不同分区的节点不能互相通信，因此无法保证一致性。

在现实的分布式系统中，网络故障是常态，在这种情况下分区容错性几乎成为了一个必要特性。因此真实的分布式系统CAP特性通常会在C和A之间做取舍。

***Reference***：

1. https://courses.grainger.illinois.edu/ece428/sp2021//assets/slides/lect25-after.pdf



#### 二阶段提交与三阶段提交

**二阶段提交**：

二阶段提交协议用于分布式事务的提交，其主要分为两个阶段，分别是投票阶段和决定阶段：

<img src="/Users/zhoushichen/Desktop/interview/Distributed-System/image/The-2-phase-commit-protocol.png" alt="The-2-phase-commit-protocol" style="zoom:50%;" />

1. 在投票阶段，协调者会给每一参与事务的服务器发送prepare信息，接收到prepare信息的服务器会根据内部的事务隔离规则和一致性检查决定事物是否能提交，并发送YES/NO信息回协调人。
2. 在决定阶段，协调者如果收到服务器的应答信息都为YES，则发送COMMIT信息，代表事物能够成功提交；否则协调者发送ABORT信息，表示投票阶段有服务器投了NO，代表事物需要回滚。服务器接收到COMMIT/ABORT后会在本地提交或者回滚信息，并发送ack应答信息回协调者，代表二阶段提交结束。

**应对协调者和服务器故障**：

1. 协调者需要持久化存储所有二阶段提交中的状态，例如收到的投票信息以及自己发送过的信息和做出的提交决定
2. 服务器需要持久化存储所有存储对象的暂定修改信息

**二阶段提交存在的问题**：

1. 在任何阶段，如果因服务器故障导致协调者没有收到正确数量的响应，或者协调者发生故障时，对应的事务提交的流程会被阻塞
2. 协调人发送COMMIT/ABORT信息后，如果有的服务器收到decision信息而有的服务器没收到时，会出现数据不一致

**三阶段提交**：

2PC最大的缺陷在于，当服务器接收到decision信息时不会去确认其于服务器是否也收到decision信息，而是直接根据decision信息作出相应的提交或回滚操作。这时如果协调者和已提交事物的服务器宕机，则无法判断事物最终的提交决定。剩余的服务器既不能悲观地回滚（因为可能某一宕机的服务器已经提交了），也不能乐观地提交（因为最终决定未知），导致永久阻塞。3PC就是为了解决这一问题而设计。

<img src="/Users/zhoushichen/Desktop/interview/Distributed-System/image/The-3-phase-commit-protocol.png" alt="The-3-phase-commit-protocol" style="zoom:50%;" />

三阶段提交的三个阶段分别是投票阶段、传播阶段、决定阶段：

1. 在投票阶段，协调者发送vote request信息给所有服务器，如果所有服务器都投YES，则进入传播阶段；如果有任意一个服务器投NO，则直接进入决定阶段进行回滚。
2. 在传播阶段，协调者会发送prepareToCommit（预提交）信息，服务器接收到预提交信息后会进入预提交状态，但不会立马执行提交操作
3. 在决定阶段，协调者会发送COMMIT/ABORT信息，服务器收到后会相应做出提交或回滚操作。此时即使协调者宕机，服务器也能在超时后自动提交或回滚（因为预提交阶段后服务器知道了其余服务器的最终决定）

***Reference***：

1. https://courses.grainger.illinois.edu/ece428/sp2021//assets/slides/lect22-after.pdf
2. https://www.the-paper-trail.org/post/2008-11-27-consensus-protocols-two-phase-commit/
3. https://www.the-paper-trail.org/post/2008-11-29-consensus-protocols-three-phase-commit/



#### 乐观锁、悲观锁

乐观锁和悲观锁是两种不同锁模型（并非真正的锁）

**乐观锁**：乐观锁会假设访问数据不会被修改，因此操作数据时不会给数据加锁，而是在之后判断操作冲突（例如提交时）。实现协议：时间戳排序

**悲观锁**：悲观锁会假设访问的数据总是会被修改，因此操作数据时会给数据加锁。实现协议：二阶段锁

***Reference***：

1. https://courses.grainger.illinois.edu/ece428/sp2021//assets/slides/lect19-after.pdf



#### 时间戳排序



***Reference***：

1. https://courses.grainger.illinois.edu/ece428/sp2021//assets/slides/lect19-after.pdf



##### 事物（ACID）实现

##### 事物隔离

##### 死锁

##### 一致性哈希





# Raft共识算法

### 项目描述

1. 使用Go语言实现Raft算法，实现集群节点状态的一致性 
2. 使用goroutine和channel完成线程同步，实现Raft领袖选举算法 
3. 实现Raft日志同步，并增加快速回退机制加快不一致日志的覆盖速率



### 相关知识点

##### 进程、线程、协程

##### GMP调度模型

##### Golang垃圾回收

##### RPC

##### 日志一致性算法（Paxos、Raft）





# 中间人攻击

### 项目描述

1. 伪造ARP协议响应，使主机成为中间人以进行报文传输监控及信息篡改 
2. 通过修改TCP传输报文中的序列号、应答号及校验和等头部信息，实现信息的篡改 
3. 使用Wireshark监控主机之间的TCP包传输



### 相关知识点

##### TCP/UDP

##### ARP欺骗

##### HTTPS

##### 加密算法

