# **Mysql**



## **关系键**

**主键**：能唯一标识表中每一行的键，一个数据表只能有一个主键，且不能为Null（从候选键中选出一个作为主键）  
**超键**：能唯一标识一行数据的属性集  
**候选键**：不含有多余属性的超键  
**外键**：其他表的主键，多用于join联表   

<img src="./image/database keys.png" alt="alt text" style="zoom:50%;" align="left"/>



## **数据库三范式**

数据库范式是为了解决数据冗余的问题，数据冗余可能会造成数据库的插入、删除、更新异常    

**1NF**：

1. 每一行都是唯一的  
2. 每一个字段的数据都是不可再分的，只能存放单一的值   

**2NF**：

1. 必须符合1NF  
2. 不存在部分函数依赖（所有非主属性都必须完全函数依赖于候选键）   
3. Example：比如学生表（学号、姓名、课程号、学分），这里姓名依赖学号、学分依赖课程号，第二范式强调非主键字段必须依赖主键，所以不符合第二范式

**3NF**：

1. 必须符合1NF和2NF  
2. 不存在传递函数依赖（所有字段都和主键直接相关，而不是间接相关）
3. Example：比如学生表（学号、姓名、年龄、学院名称、学院电话），因为存在依赖关系：学号->学生->所在学院->学院电话，而第三范式要求任何字段都不能由其他字段派生出来，它要求字段没有冗余，即不存在传递依赖



## **范式化与反范式化的优缺点**

**范式化**：

1. 减少了数据冗余的情况，并部分解决了数据冗余带来的插入、删除、更新异常

2. 范式化后的数据表通常比反范式化的表更小  
3. 数据重复的情况少，更新快   
4. 范式化拆分了更多表，增加了join操作的使用，降低了查询效率

**反范式化**：

1. 可以减少join操作的使用  
2. 数据冗余，并存在插入、删除、更新异常



## 存储引擎：InnoDB、MyISAM

1. InnoDB支持事物，MyISAM不支持
2. InnoDB支持外键，MyISAM不支持
3. InnoDB的主键索引为聚簇索引，而MyISAM的索引都是非聚簇索引
4. InnoDB最小锁粒度为行锁，MyISAM最小锁粒度为表锁



## B+树和B树的区别

<img src=".\image\b+ tree.png" alt="b+ tree" style="zoom: 67%;" align="left"/>

1. B树的所有节点都存放了key和数据（因为所有key只存了一次，所以空间利用率更高）。而B+树只有叶子结点存放了数据（或指向数据位置的指针），其余节点存放的key用于指引搜索方向。
2. B树的高度通常比B+树更高，这会增多磁盘IO的次数，减慢读取速度（原因是B树的节点存储了数据，当数据占空间大时单一节点存储的记录数变少，树的高度增加）
3. B+树的叶子结点是双向链表的结构，因此相比B树更适合范围查询



## 聚簇索引和非聚簇索引

**聚簇索引：**又称主键索引（InnoDB默认采用主键索引），每张表只能有一个主键索引，聚簇索引会将表中的数据按主键进行物理排序，因此聚簇索引的查询速度更快

**非聚簇索引：**非聚簇索引的索引结构与实际数据是分开存储的，索引结构存储了key以及key对应的数据指针，相较之下非聚簇索引的速度较慢，并需要额外的空间存储索引



## 索引优化

**前缀索引：**当使用TEXT、BLOB、VARCHAR等类型作为key建立索引时，如果key的值很长，建立索引占用的空间会变得很大，并且查询速度也会变慢。此时使用前缀索引则能节省空间并提高查询效率。   

**联合索引**：指给两个或多个字段建立索引，又称复合索引。  

**最左匹配原则**：指检索数据时从联合索引最左边开始匹配。

```mysql
CREATE INDEX idx ON table_name (col1, col2, col3);
```

以上例子中实际上会创建三个索引：（col1）（col1，col2）（col1，col2，col3）。查询语句会从联合索引的最左字段开始匹配，会在碰到范围查询时终止（如<、>、between、like）。因此建立联合索引的顺序应该符合最左匹配原则，提升索引命中率。

```mysql
SELECT * FROM table_name where a = 1 and b > 2 and c = 3; 
```

在上述例子中，如果建立索引（a，b，c）则只能用到索引（a，b）。为提高索引利用率，应建立索引（a，c，b）

**覆盖索引：**本质上和联合索引没有区别。指使用非主键索引就能得到目标字段的索引方式，覆盖索引避免了**回表查询**（回表查询：当query语句使用非聚簇索引查询时，遍历完非聚簇索引的B+树后只能得到对应的主键key值，因此还需二次遍历主键索引的B+树才能得到目标记录），显著提升查询效率



## 事物ACID特性

**Atomicity（原子性）**：每一条事物都应当被视为单一的操作，事物中的操作要么全部执行、要么全部不执行

**Consistency（一致性）**：事物在开始和结束是一定符合所有约束条件（例如假如在银行数据系统中其中一条约束条件为不允许账户余额小于0，事物在执行前后所有账户余额都不能小于0）

**Isolation（隔离性）**：并发执行的事物在全部结束后，数据库的状态应该和这几条事物串行执行的结果一样

**Durability（持久性）**：在事物提交之后，即使遇到系统崩溃数据修改也能持久化地保存（这通常意味着数据被保存到了磁盘等non-volatile memory中）



## 事物隔离级别

![isolation level](./image/isolation level.webp)

**read uncommitted（读未提交）**：事物可以到读取其他事物未提交的修改数据

**read committed（读提交）**：事物只能读取已提交的数据修改，解决了**脏读**（假设两个事物A、B，A读取了B修改但为提交的数据，如果此时B回滚，A之前读取的相关数据便无效了）

**repeatable read（重复读）**：InnoDB默认隔离级别，数据在被事物第一次读取和事物结束时状态保持一致，解决了**不可重复读**（在更低的隔离级别中，事物读取完数据后会释放对应的读锁，若之后数据被其他事物修改，再次读取数据会得到不同的结果）

**serializable（串行化）**：串行化保证并发执行的事物结果与同样的几条事物串行执行的结果一致，解决了**幻读**（假设事物A范围读取了几行数据，如果之后其他事物在该范围内插入新数据并提交，A再读取时会产生幻行）



## 事物实现原理（InnoDB）

**原子性**：**undo log 回滚日志**，Mysql可以使用undo log将数据库中的数据恢复到之前的状态。undo log是先于数据持久化到磁盘上的，因为当系统发生崩溃后用户再次启动数据库进程时，数据库系统需要能够通过查询undo log将未完成的事务回滚。

**持久性**：**redo log 重做日志**，因为缓冲池的设计，Mysql的读写性能得到大大提高。但是当系统崩溃等故障发生，而缓冲池的已提交数据还没来得及持久化到磁盘上的话，会造成提交数据的永久丢失。因此当事务提交时，数据库系统会将相关的redo log持久化到磁盘上，当上述情况发生时，系统则可以利用redo log将数据复原。

<img src=".\Image\redo log.png" style="zoom:75%;" align="left"/>

**隔离性**：Mysql事物隔离的实现方法有两种，**LBCC（lock-based concurrency control）**和 **MVCC（multi-version concurrency control）**：



1. **read uncommitted**：写操作加锁，读操作不加锁，可以提升并发性能，但会造成脏读

   <img src="/Users/zhoushichen/Desktop/interview/Database-System/Image/read uncommitted.png" alt="read uncommitted" style="zoom:27%;" align="left"/>

2. **read committed**：采用**读写分离**机制，写操作加排他锁，读操作使用了MVCC机制。

3. 



## 锁机制

**按读写划分**：

1. **共享锁（S）**：读操作使用，占有共享锁后其他事物对同一对象的读操作不会被阻塞，但是写操作会被阻塞
2. **排他锁（X）**：写操作使用，占有排他锁后其他事物对同一对象的读写操作皆被阻塞

**按粒度划分（由高到低）**：

1. **表锁**：对整个表加锁，开销小、加锁块、无死锁，但并发能力最差

2. **页锁**：介于表锁和行锁之间，不常用

3. **行锁**：对单行记录加锁，开销大、加锁慢、存在死锁问题，并发能力最强

   



